<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[平凡之路]]></title>
  <subtitle><![CDATA[coding]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://bytes1001.github.io/"/>
  <updated>2015-08-28T12:56:38.924Z</updated>
  <id>http://bytes1001.github.io/</id>
  
  <author>
    <name><![CDATA[chaofan.cui]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[10个习惯和10倍开发效率]]></title>
    <link href="http://bytes1001.github.io/2015/08/28/10xdeveloper/"/>
    <id>http://bytes1001.github.io/2015/08/28/10xdeveloper/</id>
    <published>2015-08-28T12:33:15.000Z</published>
    <updated>2015-08-28T12:56:38.924Z</updated>
    <content type="html"><![CDATA[<h4 id="英文原文_：10_habits_of_10x_developers">英文原文 ：<a href="http://adamloving.com/internet-programming/10x-developers" target="_blank" rel="external">10 habits of 10x developers</a></h4><p>Brad Feld的一篇文章《The Rise of Developeronomics》中提到了“10倍效率的开发人员（10x developer）”的概念（卓越的开发者的效率往往比一般的开发者高很多，而不只是一点点），Adam Loving 在读了之后受到启发，并向多位大牛（Ben Sharpe、Collin Watson和Jonathan Locke）询问如何成为“10倍效率的开发者”，最后得到了以下的答案。</p>
<p><strong>1. 只做需要做的工作</strong></p>
<p>使用敏捷方法；<br>全心全意做UX设计；<br>沟通第一；<br>编码也许不是解决问题的办法；<br>过早的优化是一切罪恶的根源；<br>选择最简单的解决方案。</p>
<p><strong>2. 站在巨人的肩膀上</strong></p>
<p>使用开源框架；<br>使用简洁语言；<br>不要做重复的事情（不要重新发明轮子）；<br>利用包管理器来进行公共和私有代码分配；<br>不要任凭巨头（如微软）的摆布而修复库中的一个Bug；<br>不要让你的雇主逼你学习；<br>自主学习并为自己设定新的目标。</p>
<p><strong>3. 了解数据结构和算法</strong></p>
<p>如果你不知道什么时候应该使用快速排序、不懂辨认O(n2)程序、不会写递归函数，你将无法成为10倍效率的开发者。使用多种语言你才能清楚不同的框架是如何解决相同问题的。尽可能去了解底层命令（plumbing），以便能够作出明智的决定（Web框架是怎么存储session状态的？Cookie到底是什么？）。</p>
<p><strong>4. 不要怕买工具，它可以节省你的时间</strong></p>
<p>Ben说：“昨天我花50美元买了一个位图字体工具，它帮我节省的时间成本绝对超过200美元。”</p>
<p><strong>5. 集中注意力</strong></p>
<p>不要整天开着你的电子邮件、Twitter、Facebook等，在工作时将它们最小化或关掉它们，戴上耳机。Tiny hack说：“即使不听音乐我也戴着耳机工作，这样便不会有人打扰到我。”</p>
<p><strong>6. 尽早并且经常性地进行代码重构</strong></p>
<p>有时，你不得不放弃漂亮的代码转而去寻找真正对项目有用的代码，但没关系，如果你的现有项目中有这样的代码，最好的方式便是不要看它，并重构。</p>
<p><strong>7. 只管去做</strong></p>
<p>将你的业余项目分享到Startup Weekend中。在我开始转到Unix和Ruby on Rails上之前，我买了一台Mac，使用Windows虚拟机花了一年时间做.NET项目。</p>
<p><strong>8. 挑选一个编辑器，并掌握它</strong></p>
<p>高效开发者喜欢用文本编辑器胜过IDE编辑器，因为这样可以学到更多东西。无论什么情况，尽量使用键盘快捷键，因为熟练使用一件工具的前提是熟悉它。</p>
<p>在选择编辑器时，认真考虑并挑选最好的（Emacs或Vim），因为它们是通用的。其次，挑选你的首选平台最支持的。使用宏，不断地写代码；使用Mac上的TextExpander为整个段落创建快捷方式；使用Visual Studio或SublimeText的自动补齐功能；使用支持按行/列分割窗口的编辑器，这样你便能同时看到单元测试和代码（或模型、视图）。</p>
<p>一定要想清楚后再写代码。Adam说，“我有朋友在一个大项目组里工作，他们组里最高效的程序员是一个高位截瘫用嘴叼着棍子敲代码的人，他总是在写代码之前想得很仔细且很少出错。”</p>
<p><strong>9. 整洁的代码胜过巧妙的代码</strong></p>
<p>要想让其他人能够读懂你的代码，尽量使用最少的代码来完成任务。遵循DRY（Don’t repeat yourself）的原则，使用明确定义的对象和库，将任务分解成小而简单的代码段。</p>
<p><strong>10. 潜意识是强大的工具</strong></p>
<p>离开10分钟往往就可以解决一个问题。控制编程时间，给自己一个多姿多彩的生活，劳逸结合能让你在工作时更高效、更愉悦。当然，即便是上了年纪的程序员也知道，以最少的时间完成最高效的工作是成为10倍效率开发者的必要条件。</p>
<p>作为一个程序员，我觉得在职业生涯中最好的一件事儿就是从电脑前站起来，去拜访那些在某一领域有所建树的人们。</p>
<p><strong>11. 推动自身和团队进步</strong> （加一个）</p>
<p>重视批评，以包容的态度接受批评并提升自己是非常重要的事情。没有这个基础，你不可能成为一个高效的开发者。一位智者曾经说过：“聪明的人善于从自己的错误中学习，而智慧的人善于从别人的错误中学习。”</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="英文原文_：10_habits_of_10x_developers">英文原文 ：<a href="http://adamloving.com/internet-programming/10x-developers" target="_blank" rel="ex]]>
    </summary>
    
      <category term="习惯" scheme="http://bytes1001.github.io/tags/%E4%B9%A0%E6%83%AF/"/>
    
      <category term="好文章" scheme="http://bytes1001.github.io/categories/%E5%A5%BD%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sql语句执行顺序]]></title>
    <link href="http://bytes1001.github.io/2015/08/27/sql%E6%89%A7%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>http://bytes1001.github.io/2015/08/27/sql执语句执行顺序/</id>
    <published>2015-08-27T08:33:52.000Z</published>
    <updated>2015-08-27T12:23:44.383Z</updated>
    <content type="html"><![CDATA[<p>从网上学习了下sql语句的执行顺序。做个笔记：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(8)<span class="operator">SELECT (<span class="number">9</span>)<span class="keyword">DISTINCT</span>  (<span class="number">11</span>)&lt;Top <span class="keyword">Num</span>&gt; &lt;select <span class="keyword">list</span>&gt;</span><br><span class="line">(<span class="number">1</span>)<span class="keyword">FROM</span> [left_table]</span><br><span class="line">(<span class="number">3</span>)&lt;join_type&gt; <span class="keyword">JOIN</span> &lt;right_table&gt;</span><br><span class="line">(<span class="number">2</span>)        <span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line">(<span class="number">4</span>)<span class="keyword">WHERE</span> &lt;where_condition&gt;</span><br><span class="line">(<span class="number">5</span>)<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;group_by_list&gt;</span><br><span class="line">(<span class="number">6</span>)<span class="keyword">WITH</span> &lt;<span class="keyword">CUBE</span> | <span class="keyword">RollUP</span>&gt;</span><br><span class="line">(<span class="number">7</span>)<span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line">(<span class="number">10</span>)<span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_list&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="逻辑查询处理顺序：">逻辑查询处理顺序：</h4><p>(1)<strong>FROM</strong>: 对FROM子句中的前两个表执行笛卡尔积（Cartesian product)(交叉联接），生成虚拟表VT1</p>
<p>(2)<strong>ON</strong>: 对VT1应用ON筛选器。只有那些使<join_condition>为真的行才被插入VT2。</join_condition></p>
<p>(3)<strong>OUTER(JOIN)</strong>：如果指定了OUTER JOIN（相对于CROSS JOIN 或(INNER JOIN),保留表（preserved table：左外部联接把左表标记为保留表，右外部联接把右表标记为保留表，完全外部联接把两个表都标记为保留表）中未找到匹配的行将作为外部行添加到 VT2,生成VT3.如果FROM子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤1到步骤3，直到处理完所有的表为止。</p>
<p>(4)<strong>WHERE</strong>：对VT3应用WHERE筛选器。只有使<where_condition>为true的行才被插入VT4.</where_condition></p>
<p>(5)<strong>GROUP BY</strong>：按GROUP BY子句中的列列表对VT4中的行分组，生成VT5.</p>
<p>(6)<strong>CUBE|ROLLUP</strong>：把超组(Suppergroups)插入VT5,生成VT6.</p>
<p>(7)<strong>HAVING</strong>：对VT6应用HAVING筛选器。只有使<having_condition>为true的组才会被插入VT7.</having_condition></p>
<p>(8)<strong>SELECT</strong>：处理SELECT列表，产生VT8.</p>
<p>(9)<strong>DISTINCT</strong>：将重复的行从VT8中移除，产生VT9.</p>
<p>(10)<strong>ORDER BY</strong>：将VT9中的行按ORDER BY 子句中的列列表排序，生成游标（VC10).</p>
<p>(11)<strong>TOP</strong>：从VC10的开始处选择指定数量或比例的行，生成表VT11,并返回调用者。</p>
<p>注：步骤10，按ORDER BY子句中的列列表排序上步返回的行，返回游标VC10.这一步是第一步也是唯一一步可以使用SELECT列表中的列别名的步骤。这一步不同于其它步骤的 是，它不返回有效的表，而是返回一个游标。SQL是基于集合理论的。集合不会预先对它的行排序，它只是成员的逻辑集合，成员的顺序无关紧要。对表进行排序 的查询可以返回一个对象，包含按特定物理顺序组织的行。ANSI把这种对象称为游标。理解这一步是正确理解SQL的基础。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从网上学习了下sql语句的执行顺序。做个笔记：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="]]>
    </summary>
    
      <category term="sql" scheme="http://bytes1001.github.io/tags/sql/"/>
    
      <category term="sql" scheme="http://bytes1001.github.io/categories/sql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IEnumerator &IEnumerable]]></title>
    <link href="http://bytes1001.github.io/2015/08/17/ienumerator/"/>
    <id>http://bytes1001.github.io/2015/08/17/ienumerator/</id>
    <published>2015-08-17T01:31:35.000Z</published>
    <updated>2015-08-17T01:43:35.979Z</updated>
    <content type="html"><![CDATA[<p>先看看<strong>IEnumerator</strong> 和<strong>IEnumerable</strong>的接口定义:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">System.Collections</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">//     公开枚举数，该枚举数支持在非泛型集合上进行简单迭代。</span></span><br><span class="line">    [ComVisible(<span class="keyword">true</span>)]</span><br><span class="line">    [Guid(<span class="string">"496B0ABE-CDEE-11d3-88E8-00902754C43A"</span>)]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 摘要:</span></span><br><span class="line">        <span class="comment">//     返回一个循环访问集合的枚举数。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 返回结果:</span></span><br><span class="line">        <span class="comment">//     一个可用于循环访问集合的 System.Collections.IEnumerator 对象。</span></span><br><span class="line">        [DispId(-<span class="number">4</span>)]</span><br><span class="line">        <span class="function">IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">//     支持对非泛型集合的简单迭代。</span></span><br><span class="line">    [ComVisible(<span class="keyword">true</span>)]</span><br><span class="line">    [Guid(<span class="string">"496B0ABF-CDEE-11d3-88E8-00902754C43A"</span>)]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 摘要:</span></span><br><span class="line">        <span class="comment">//     获取集合中的当前元素。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 返回结果:</span></span><br><span class="line">        <span class="comment">//     集合中的当前元素。</span></span><br><span class="line">        <span class="keyword">object</span> Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">        <span class="comment">// 摘要:</span></span><br><span class="line">        <span class="comment">//     将枚举数推进到集合的下一个元素。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 返回结果:</span></span><br><span class="line">        <span class="comment">//     如果枚举数成功地推进到下一个元素，则为 true；如果枚举数越过集合的结尾，则为 false。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 异常:</span></span><br><span class="line">        <span class="comment">//   System.InvalidOperationException:</span></span><br><span class="line">        <span class="comment">//     在创建了枚举数后集合被修改了。</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 摘要:</span></span><br><span class="line">        <span class="comment">//     将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 异常:</span></span><br><span class="line">        <span class="comment">//   System.InvalidOperationException:</span></span><br><span class="line">        <span class="comment">//     在创建了枚举数后集合被修改了。</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>三种迭代集合的方式</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">var</span> en = list.GetEnumerator();</span><br><span class="line">    <span class="keyword">while</span> (en.MoveNext())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = en.Current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> list)<span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = list[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>foreach 和 for 都可以迭代枚举集合中的元素。foreach是对象迭代器，语法更简洁，它要求list实现IEnumerable 接口的GetEnumerator方法。</p>
<p><strong>自定义一个集合类型</strong><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyCarIEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Garage</span>:<span class="title">IEnumerable</span></span><br><span class="line">    &#123;</span><br><span class="line">        Car[] carArray = <span class="keyword">new</span> Car[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">//启动时填充一些Car对象</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Garage</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            carArray[<span class="number">0</span>] = <span class="keyword">new</span> Car(<span class="string">"Rusty"</span>, <span class="number">30</span>);</span><br><span class="line">            carArray[<span class="number">1</span>] = <span class="keyword">new</span> Car(<span class="string">"Clunker"</span>, <span class="number">50</span>);</span><br><span class="line">            carArray[<span class="number">2</span>] = <span class="keyword">new</span> Car(<span class="string">"Zippy"</span>, <span class="number">30</span>);</span><br><span class="line">            carArray[<span class="number">3</span>] = <span class="keyword">new</span> Car(<span class="string">"Fred"</span>, <span class="number">45</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.carArray.GetEnumerator();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改Garage类型之后，就可以在C#foreach结构中安全使用该类型了。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//除此之外，GetEnumerator()被定义为公开的，对象用户可以与IEnumerator类型交互：</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyCarIEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"*********Fun with IEnumberable/IEnumerator************\n"</span>);</span><br><span class="line">            Garage carLot = <span class="keyword">new</span> Garage();</span><br><span class="line">            <span class="comment">//交出集合中的每一Car对象吗</span></span><br><span class="line">            <span class="keyword">foreach</span> (Car c <span class="keyword">in</span> carLot)  <span class="comment">//之所以遍历carLot，是因为carLot.GetEnumerator()返回的项时Car类型，这个十分重要</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"&#123;0&#125; is going &#123;1&#125; MPH"</span>, c.CarName, c.CurrentSpeed);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">"GetEnumerator被定义为公开的，对象用户可以与IEnumerator类型交互，下面的结果与上面是一致的"</span>);</span><br><span class="line">            <span class="comment">//手动与IEnumerator协作</span></span><br><span class="line">            IEnumerator i = carLot.GetEnumerator();</span><br><span class="line">            <span class="keyword">while</span> (i.MoveNext())</span><br><span class="line">            &#123;</span><br><span class="line">                Car myCar = (Car)i.Current;</span><br><span class="line">                Console.WriteLine(<span class="string">"&#123;0&#125; is going &#123;1&#125; MPH"</span>, myCar.CarName, myCar.CurrentSpeed);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>自己实现IEnumerator接口</strong><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ForeachTestCase</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">//继承IEnumerable接口，其实也可以不继承这个接口，只要类里面含有返回IEnumberator引用的GetEnumerator()方法即可</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">ForeachTest</span>:<span class="title">IEnumerable</span>     &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">string</span>[] elements;  <span class="comment">//装载字符串的数组</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ctr = <span class="number">0</span>;  <span class="comment">//数组的下标计数器</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> 初始化的字符串</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="initialStrings"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        ForeachTest(<span class="keyword">params</span> <span class="keyword">string</span>[] initialStrings)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//为字符串分配内存空间</span></span><br><span class="line">            elements = <span class="keyword">new</span> String[<span class="number">8</span>];</span><br><span class="line">            <span class="comment">//复制传递给构造方法的字符串</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">string</span> s <span class="keyword">in</span> initialStrings)</span><br><span class="line">            &#123;</span><br><span class="line">                elements[ctr++] = s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span>  构造函数</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="source"&gt;</span>初始化的字符串<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="delimiters"&gt;</span>分隔符，可以是一个或多个字符分隔<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        ForeachTest(<span class="keyword">string</span> initialStrings, <span class="keyword">char</span>[] delimiters)</span><br><span class="line">        &#123;</span><br><span class="line">            elements = initialStrings.Split(delimiters);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现接口中得方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">new</span> ForeachTestEnumerator(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">ForeachTestEnumerator</span> : <span class="title">IEnumerator</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> position = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">private</span> ForeachTest t;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">ForeachTestEnumerator</span>(<span class="params">ForeachTest t</span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.t = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">region</span> 实现接口</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">object</span> Current</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">get</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> t.elements[position];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (position &lt; t.elements.Length - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    position++;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                position = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="preprocessor">#<span class="keyword">endregion</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="comment">// ForeachTest f = new ForeachTest("This is a sample sentence.", new char[] &#123; ' ', '-' &#125;);</span></span><br><span class="line">            ForeachTest f = <span class="keyword">new</span> ForeachTest(<span class="string">"This"</span>, <span class="string">"is"</span>, <span class="string">"a"</span>, <span class="string">"sample"</span>, <span class="string">"sentence."</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">string</span> item <span class="keyword">in</span> f)</span><br><span class="line">            &#123;</span><br><span class="line">                System.Console.WriteLine(item);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>通过以上代码，我们知道:</strong></p>
<p>foreach 迭代集合的本质还是通过索引的方式。通过IEnumerator包装了索引访问从而实现对象访问的方式。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>先看看<strong>IEnumerator</strong> 和<strong>IEnumerable</strong>的接口定义:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><p]]>
    </summary>
    
      <category term="c#" scheme="http://bytes1001.github.io/tags/c/"/>
    
      <category term=".net基础" scheme="http://bytes1001.github.io/categories/net%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[for vs foreach]]></title>
    <link href="http://bytes1001.github.io/2015/08/16/for-foreach/"/>
    <id>http://bytes1001.github.io/2015/08/16/for-foreach/</id>
    <published>2015-08-16T07:40:24.000Z</published>
    <updated>2015-08-17T01:55:17.229Z</updated>
    <content type="html"><![CDATA[<h5 id="翻墙出去，找到的一篇文章。比较好，随手就copy_分享给大家。英文不好的_请略过…">翻墙出去，找到的一篇文章。比较好，随手就copy 分享给大家。英文不好的  请略过…</h5><p>For vs. Foreach. For and foreach differ slightly in performance. They are approximately the same speed. But the foreach loop uses more stack space for local variables. In this comparison, we strive to understand the exact difference in the two loops.</p>
<p>Comparison. First, let’s look at the version of the loop that uses the for loop (Method1) and the version that uses the foreach-loop (Method2). Each method sums all the elements in an integer array.<br><strong>For loop version: Method1</strong><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Method1</span>(<span class="params"><span class="keyword">int</span>[] array</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">	a += array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Foreach loop version: Method2</strong><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Method2</span>(<span class="params"><span class="keyword">int</span>[] array</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">int</span> <span class="keyword">value</span> <span class="keyword">in</span> array)</span><br><span class="line">    &#123;</span><br><span class="line">	a += <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Difference. In .NET 4.0, we see a difference in the IL. The Method1 version uses enough stack space for only two local variables (a and i). The Method2 version uses stack space for four locals (a, value, and two compiler-generated temporaries).<br>IL<br>When a method is called in the Common Language Runtime, all of the memory required for the locals is allocated upon the stack. Because this takes place on the stack, this process is fast, but it is not free.<br>Thus:The foreach-loop will incur a small cost due to its extra two local variables.</p>
<p>Benchmark. Now, let’s test these two methods against each other. When testing, try altering the order of the methods such that Method2 is tested before Method1. You will need to paste Method1 and Method2 into the Program class.<br>Note:The foreach version was slower than the for version. This is because the foreach-version uses more local variable space.<br><strong>C# program that benchmarks methods</strong><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">	Method1(array);</span><br><span class="line">	Method2(array);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> s1 = Stopwatch.StartNew();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> m = <span class="number">100000000</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	    Method1(array);</span><br><span class="line">	&#125;</span><br><span class="line">	s1.Stop();</span><br><span class="line">	<span class="keyword">var</span> s2 = Stopwatch.StartNew();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	    Method2(array);</span><br><span class="line">	&#125;</span><br><span class="line">	s2.Stop();</span><br><span class="line">	Console.WriteLine(((<span class="keyword">double</span>)(s1.Elapsed.TotalMilliseconds *</span><br><span class="line">	    <span class="number">1000000</span>) / m).ToString(<span class="string">"0.00 ns"</span>));</span><br><span class="line">	Console.WriteLine(((<span class="keyword">double</span>)(s2.Elapsed.TotalMilliseconds *</span><br><span class="line">	    <span class="number">1000000</span>) / m).ToString(<span class="string">"0.00 ns"</span>));</span><br><span class="line">	Console.Read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Output</strong></p>
<p>7.37 ns<br>8.04 ns</p>
<p>Benchmark 2. The extra local variables in the foreach loop slow down the simple loop. However, it is possible to use those local variables to our advantage. Let’s change the loops to have two statements that access the value.<br><strong>For loop alternate version: Method1</strong><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Method1</span>(<span class="params"><span class="keyword">int</span>[] array</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">	a += array[i];</span><br><span class="line">	a += array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Foreach loop alternate version: Method2</strong><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Method2</span>(<span class="params"><span class="keyword">int</span>[] array</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">int</span> <span class="keyword">value</span> <span class="keyword">in</span> array)</span><br><span class="line">    &#123;</span><br><span class="line">	a += <span class="keyword">value</span>;</span><br><span class="line">	a += <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Results</strong></p>
<p>7.71 ns<br>7.69 ns</p>
<p>New results. Now, the for loop is slightly slower than the foreach loop. This is because the local variable that stores the value of the element in the array is faster to access than an element in the array.</p>
<p><strong>Summary.</strong> In micro-benchmarking, introducing extra local variables with foreach-loops can impact performance. However, if those local variables are reused several times in the loop body, they can lead to a performance improvement.<br>Thus:The for-loop is faster than the foreach-loop if the array must only be accessed once per iteration.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h5 id="翻墙出去，找到的一篇文章。比较好，随手就copy_分享给大家。英文不好的_请略过…">翻墙出去，找到的一篇文章。比较好，随手就copy 分享给大家。英文不好的  请略过…</h5><p>For vs. Foreach. For and foreach differ]]>
    </summary>
    
      <category term="c#" scheme="http://bytes1001.github.io/tags/c/"/>
    
      <category term=".net基础" scheme="http://bytes1001.github.io/categories/net%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Dispose模式]]></title>
    <link href="http://bytes1001.github.io/2015/08/15/dispose/"/>
    <id>http://bytes1001.github.io/2015/08/15/dispose/</id>
    <published>2015-08-15T03:09:58.000Z</published>
    <updated>2015-08-17T01:55:30.853Z</updated>
    <content type="html"><![CDATA[<h4 id="我们知道在托管代码里调用非托管资源时，需要显式释放非托管资源">我们知道在托管代码里调用非托管资源时，需要显式释放非托管资源</h4><p>有两种方式：</p>
<p><strong>1.主动释放</strong>（<em>调用者调用dispose</em>）</p>
<p>优点：效率高，资源释放快。<br>缺点：调用者可能忘记调用dispose方法，造成资源没有释放</p>
<p><strong>2.被动释放</strong>（<em>析构函数里dispose</em>）</p>
<p>优点：即使调用者没有调用dispose方法，资源也会在GC的时候dispose<br>缺点：效率低，不知道GC什么时候进行，而且这种方式也增加了GC的负担</p>
<p>微软的.net团队给出了资源释放的Dispose模式，兼顾了类型安全性与执行效率。</p>
<p>下面是我写的dispose模式具体例子，</p>
<p>MyResourceWrapper类型调用win api向外部暴露Graphics。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">GC</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> 这个类包装了非托管资源。</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="keyword">public</span>  <span class="keyword">class</span> <span class="title">MyResourceWrapper</span>:<span class="title">IDisposable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> IntPtr handle;<span class="comment">//句柄,非托管资源</span></span><br><span class="line">        <span class="keyword">public</span> Graphics Graphics</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> Graphics.FromHdc(handle);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">bool</span> disposed = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        MyResourceWrapper()</span><br><span class="line">        &#123;</span><br><span class="line">            handle = GetDC(IntPtr.Zero);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            CleanUp(<span class="keyword">true</span>);<span class="comment">//释放资源</span></span><br><span class="line">            System.GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//析构方法应该只释放非托管资源。不要释放托管资源。</span></span><br><span class="line">        <span class="comment">//因为GC回收时，有可能托管类型已经被释放掉。会导致抛异常。</span></span><br><span class="line">        <span class="comment">//定义析构函数会导致至少两次垃圾回收，效能低下。</span></span><br><span class="line">        ~MyResourceWrapper()</span><br><span class="line">        &#123;</span><br><span class="line">            CleanUp(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="xmlDocTag">///</span></span></span><br><span class="line">      <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="flag"&gt;</span>标识清理托管资源还是非托管资源<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">CleanUp</span>(<span class="params"><span class="keyword">bool</span> flag</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.disposed)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//释放托管资源</span></span><br><span class="line">                    Console.WriteLine(<span class="string">"成功释放非托管资源！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//释放非托管资源</span></span><br><span class="line">                ReleaseDC(IntPtr.Zero,handle);</span><br><span class="line">                Console.WriteLine(<span class="string">"成功释放托管资源！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            disposed = <span class="keyword">true</span>;<span class="comment">//已经清理</span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="xmlDocTag">///</span> 目的在于说明这个类的高效率Dispose模式。</span></span><br><span class="line">      <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> re=<span class="keyword">new</span> MyResourceWrapper())</span><br><span class="line">            &#123;</span><br><span class="line">                re.Graphics.DrawEllipse(<span class="keyword">new</span> Pen(Color.Red),<span class="number">100</span>,<span class="number">100</span>,<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="xmlDocTag">///</span> 目的在于说明开发者忘记去调用dispose方法释放资源了。</span></span><br><span class="line">      <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TestFinalize</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> re = <span class="keyword">new</span> MyResourceWrapper();</span><br><span class="line">            re.Graphics.DrawEllipse(<span class="keyword">new</span> Pen(Color.Red), <span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">            re = <span class="keyword">null</span>;</span><br><span class="line">            System.GC.Collect();</span><br><span class="line">            System.GC.WaitForPendingFinalizers();</span><br><span class="line">        &#125;</span><br><span class="line">        [System.Runtime.InteropServices.DllImport(<span class="string">"User32.dll"</span>)]</span><br><span class="line">         <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">GetDC</span>(<span class="params">IntPtr Hwnd</span>)</span>;</span><br><span class="line"> </span><br><span class="line">        [System.Runtime.InteropServices.DllImport(<span class="string">"User32.dll"</span>)]</span><br><span class="line">         <span class="function"><span class="keyword">static</span>  <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">ReleaseDC</span>(<span class="params">IntPtr hWnd, IntPtr hDC</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="我们知道在托管代码里调用非托管资源时，需要显式释放非托管资源">我们知道在托管代码里调用非托管资源时，需要显式释放非托管资源</h4><p>有两种方式：</p>
<p><strong>1.主动释放</strong>（<em>调用者调用dispose</em>）</]]>
    </summary>
    
      <category term="GC" scheme="http://bytes1001.github.io/tags/GC/"/>
    
      <category term=".net基础" scheme="http://bytes1001.github.io/categories/net%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[programer]]></title>
    <link href="http://bytes1001.github.io/2015/08/14/cat/"/>
    <id>http://bytes1001.github.io/2015/08/14/cat/</id>
    <published>2015-08-14T01:38:09.000Z</published>
    <updated>2015-08-18T02:59:10.755Z</updated>
    <content type="html"><![CDATA[<p>hi.</p>
<p><img src="http://bytes.oss-cn-hangzhou.aliyuncs.com/blog%2Fmonkey.jpg" alt="cat"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>hi.</p>
<p><img src="http://bytes.oss-cn-hangzhou.aliyuncs.com/blog%2Fmonkey.jpg" alt="cat"></p>
]]>
    </summary>
    
      <category term="随笔" scheme="http://bytes1001.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="随笔" scheme="http://bytes1001.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
